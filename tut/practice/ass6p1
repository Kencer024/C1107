//close addressing
int HashInsert(HashTable* Q1Ptr, int key)
{
    //Write your code here
    ListNode *temp, *newNode;

    if(HashSearch(*Q1Ptr, key) != NULL)
        return 0;

    int index = Hash(key, Q1Ptr->hSize);


    newNode = malloc(sizeof(ListNode));
    newNode->key = key;
    newNode->next = NULL;
    newNode->pre = NULL;

    temp = Q1Ptr->Table[index].head;
    if(temp == NULL)
    {
        Q1Ptr->Table[index].head = newNode;
        Q1Ptr->Table[index].head->next = NULL;
    }

    else
    {
        newNode->next = Q1Ptr->Table[index].head;
        Q1Ptr->Table[index].head->pre = newNode;
        Q1Ptr->Table[index].head = newNode;
    }

    Q1Ptr->Table[index].size++;
    Q1Ptr->nSize++;

    return 1;

}

int HashDelete(HashTable* Q1Ptr, int key)
{
    //Write your code here
    ListNode *temp;

    if(HashSearch(*Q1Ptr, key)==NULL)
        return 0;

    int index = Hash(key, Q1Ptr->hSize);

    temp = HashSearch(*Q1Ptr, key);
    if(temp->next != NULL && temp->pre != NULL)
    {
        temp->pre->next = temp->next;
        temp->next->pre = temp->pre;
    }
    else if(temp->next == NULL)
    {
        temp->pre->next = NULL;
    }
    else
    {
        Q1Ptr->Table[index].head = temp->next;
    }
    Q1Ptr->Table[index].size--;
    Q1Ptr->nSize--;
    return 1;
}

//open addr
int HashInsert(int key, HashSlot hashTable[])
{
   //Write your code here
    int index, keymod,i=0, n=0,del_,del_comp=0;



    keymod = hash2(key);
    //checking for duplicate keys
    while(i<TABLESIZE)
        {
            index = hash1(key+i*keymod);

            if(hashTable[index].indicator == EMPTY)
            {
                hashTable[index].indicator = USED;
                hashTable[index].key = key;
                return n;
            }

            else if(hashTable[index].indicator ==USED)
            {
                n++;
                if(hashTable[index].key == key)
                    return -1;
            }


            else //still need other slots for duplicates
            {
                del_comp = i;
                while(del_comp < TABLESIZE)
                {
                    del_ = hash1(key + del_comp*keymod); //use del_ to traverse to check for dupes
                    if(hashTable[del_].indicator == USED)
                    {
                        n++;
                        if(hashTable[del_].key == key)
                            return -1;
                    }
                    else if(hashTable[del_].indicator == EMPTY)
                    {
                        hashTable[index].indicator = USED;
                        hashTable[index].key = key;
                        return n;
                    }
                    del_comp++;
                }

            }


            i++;
        }
        return n;



}

int HashDelete(int key, HashSlot hashTable[])
{
    //Write your code here

    int index, keymod,i=0, n=0, j=0;



    index = hash1(key);
    keymod = hash2(key);

    while(n<TABLESIZE)
        {

            if(hashTable[index].indicator == EMPTY)
                return -1;

            if(hashTable[index].key == key)
            {
                if(hashTable[index].indicator == DELETED)
                {
                    j++;
                    n++;

                }
                else
                {
                    hashTable[index].indicator = DELETED;
                    return n+1-j;
                }

            }
            i++;
            n++;

            index = hash1(key+i*keymod);

        }

    return -1;
}
