
//doubly linked list with 1 test case error
int HashInsert(HashTable* Q1Ptr, int key)
{
    //Write your code here
    int index;
    ListNode *newNode, *temp;

    if(HashSearch(*Q1Ptr, key)!=NULL)   //duplicate
        return 0;

    if(Q1Ptr->hSize!=0)
        index  = Hash(key,Q1Ptr->hSize);

    //The key is inserted from the front.
    newNode = (ListNode *) malloc(sizeof(ListNode));
    newNode->key = key;
    newNode->next= Q1Ptr->Table[index].head;
    //temp = newNode->next;
    Q1Ptr->Table[index].head = newNode;
    if(Q1Ptr->Table[index].size!= 0)
        Q1Ptr->Table[index].head->next->pre = Q1Ptr->Table[index].head;

    Q1Ptr->Table[index].size++;
    Q1Ptr->nSize++;

    return 1; //insertion is done successfully

}

int HashDelete(HashTable* Q1Ptr, int key)
{


    //Write your code here
    int index;
    ListNode *temp;

    if(HashSearch(*Q1Ptr, key)==NULL)   //duplicate
        return 0;

    if(Q1Ptr->hSize!=0)
        index  = Hash(key,Q1Ptr->hSize);

    //The key is inserted from the front.
    temp = HashSearch(*Q1Ptr, key);
    //printf("temp is %d\n",temp->pre->key);
    if(temp->pre != NULL && temp->next != NULL)
        temp->pre->next = temp->next;
    else if(temp->pre == NULL)
    {
        Q1Ptr->Table[index].head = temp->next;
    }
    else if(temp->next == NULL)
    {
        temp->pre->next = NULL;
    }
    Q1Ptr->Table[index].size--;
    Q1Ptr->nSize--;
    free(temp);

    return 1; //insertion is done successfully

}


//zavier ans
int HashInsert(HashTable* Q1Ptr, int key)
{
    //Write your code here
    int index;
    ListNode *newNode, *temp;

    if(HashSearch(*Q1Ptr, key)!=NULL)   //duplicate
        return 0;

    if(Q1Ptr->hSize!=0)
        index  = Hash(key,Q1Ptr->hSize);

    //The key is inserted from the front.
    newNode = (ListNode *) malloc(sizeof(ListNode));
    newNode->key = key;
    newNode->next= NULL;
    newNode->pre = NULL;

    temp = Q1Ptr->Table[index].head;

    if(temp == NULL)
    {
        Q1Ptr->Table[index].head = newNode;
        Q1Ptr->Table[index].head->next = NULL;
    }
    //temp = newNode->next;
    else
    {
        newNode->next = Q1Ptr->Table[index].head;
        Q1Ptr->Table[index].head->pre = newNode;
        Q1Ptr->Table[index].head = newNode;
    }


    (Q1Ptr->Table[index].size)++;
    //Q1Ptr->nSize++;

    return 1; //insertion is done successfully

}

//open addr
int HashInsert(int key, HashSlot hashTable[])
{
   //Write your code here

    int index, keymod,i=0, n=0;

    index = hash1(key);


    //checking for duplicate keys
    //if table is full and insert duplicate keys
    
    while(i<TABLESIZE)
        {
            i++;
            if(hashTable[i].key == key)
                return -1;
        }

    i=0; //i=0 for traversal later

    //If its empty then can just insert else mod the key then add to key then hash
    if(hashTable[index].indicator == DELETED || hashTable[index].indicator == EMPTY)
    {
        hashTable[index].indicator = USED;
        hashTable[index].key = key;

    }
    else if(hashTable[index].indicator != EMPTY)
    {
        //check for duplicate keys
        //if slot is deleted, but need check for duplicates 1st then can just insert in

        keymod = hash2(key);

        while(hashTable[index].indicator != EMPTY)
        {
            if(n>=TABLESIZE)
                return n;
            i++;
            n++;
            index = hash1(key+i*keymod);
            if(hashTable[index].indicator == DELETED || hashTable[index].indicator == EMPTY)
                break;


        }



        hashTable[index].indicator = USED;
        hashTable[index].key = key;
    }



    return n; //insertion is done successfully

}

int HashDelete(int key, HashSlot hashTable[])
{
    //Write your code here

    int index, keymod,i=0, n=0;



    index = hash1(key);
    keymod = hash2(key);

    while(hashTable[index].indicator == USED)
        {
            if(n>=TABLESIZE)
                return n;

            i++;
            n++;


            if(hashTable[index].indicator == DELETED)
                index++;
            if(hashTable[index].key == key)
            {
                hashTable[index].indicator = DELETED;
                return n;
            }

            index = hash1(key+i*keymod);

        }

    return -1;
}
