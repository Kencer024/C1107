void removeUntil(Stack *s, int value){

	// write your code here
	//ListNode *cur;
	//cur = s->tail;
	if(s == NULL)return;
	while(pop(s) != value){}
	push(s, value);
}

////////////////////////////////////////////////////////////
//Question 2

void recursiveReverse(Queue *q){

	// write your code here
	Stack s;
	//LinkedList a,b;
	int temp;
	s.ll.head = NULL;
	s.ll.size = 0;
	while(isEmptyQueue(q)!=1){
            temp = dequeue(q);
            push(&s,temp);
	}
	while(isEmptyStack(&s)!=1){
	    temp = pop(&s);
        enqueue(q,temp);
	}
}

////////////////////////////////////////////////////////////
//Question 3

int palindrome(char *word){

	// write your code here
	Queue q, q1;
	int flag =0;
	q1.ll.head = NULL;
	q1.ll.size = 0;
	q.ll.head = NULL;
	q.ll.size =0;
	int i =0;
	while(*word != '\0'){
            if(*word != 32){
            push(&q,tolower(*word));
            }
            word++;
	}
	q1 = q;
	//printf("list 1 is\n");
	printList(&q);
	//printf("list 2 is\n");
	//printList(&q1);
	recursiveReverse(&q);
	//printf("list 1 is\n");
	printList(&q);
	while(!isEmptyQueue(&q)){
        if(dequeue(&q)!=dequeue(&q1)){
                flag =1;
                break;

	}}
	if(flag == 1){printf("The string is not a palindrome\n");return -1;}
	if(flag == 0){printf("The string is a palindrome\n");return 0;}
	return -1;
}

////////////////////////////////////////////////////////////
//Question 4
	// Check one character at a time
	// If we see an opening bracket, store it in a stack
	// If we see a closing bracket, check stack for matching opening bracket (should be on top)
	// The moment we see a mismatch, expression is not balanced, return
	// If we finish looking at the expression and the stack is empty, it's balanced

int balanced(char *expression){

	// write your code here
	Stack s;
	s.ll.head = NULL;
	s.ll.tail = NULL;
	s.ll.size = 0;
	printf("%s\n", expression);             //%s requires a pointer
	printf("%c\n", *expression);            //%c is *char

    // only push opening brackets and check the closing bracketsw
    while(*expression){
        if(*expression == '(' || *expression == '[' || *expression == '{'){
            push(&s, *expression);
           }
        else if (*expression == ')'){
            if(isEmptyStack(&s) || pop(&s) != '(')
                return -1;
        }
        else if (*expression == '}'){
            if(isEmptyStack(&s) || pop(&s) != '{')
                return -1;
        }
        else if(*expression == ']' ){
            if(isEmptyStack(&s) || pop(&s) != '[')
                return -1;
        }
        expression++;
    }

    if(isEmptyStack(&s))return 0;
    else return -1;



}

////////////////////////////////////////////////////////////////////////////////

